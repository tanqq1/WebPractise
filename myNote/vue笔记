获取网页链接中的传过来的数据：

vue路由的操作： this.$route.query.dif-----dif为路由中传过来的字段名


VUE的生命周期钩子

|--beforecreate
|---------------在这个生命周期内,进行初始化时间，进行数据的监测。在created的时候数据已经和data属性进行了绑定
|---------------此时没有进行DOM的挂载
|--create
|---------------在这个生命周期的过程中，首先会判断是否有el选项，如果有，则往下编译。其中el就是挂载的dom节点
|---------------如果没有，则直到vue实例调用vm.$mount(el)，否则生命周期将停止。。
|---------------接下来看是否有template选项，如果有，就将template作为一个模板编译成一个render函数；
|---------------如果没有，就将el的外部html内容作为一个template。。。。可见，template的优先级较高
|===============在vue中还有一个render函数，以createElement作为参数，然后做渲染操作
|--beforeMount
|---------------vue实例对象添加$el成员，并且替换掉挂载在的DOM对象.这时候只是用{{message}}、{{data}}来进行占位，并没有替换成相应的数据
|--Mount
|---------------这个生命周期里，将{{message}}、{{data}}替换成相应的渲染数据
|--beforeUpdate
|--Update
|--beforeDestroy
|--Destroy
|---------------在调用vm.$destroy()之后，实例被销毁，但是dom和属性方法等还依旧存在，只是改变他们讲不会生效。。


父子组件的生命周期(暂时不做深入了解，等有进一步学习以后再仔细研究)
        参考网址：  https://segmentfault.com/a/1190000014705819
        1、仅当子组件完成挂载后，父组件才会挂载
        2、当子组件完成挂载后，父组件会主动执行一次beforeUpdate/update钩子函数（仅首次）
        3、父子组件在data变化时是分别监控的，但是在更新prop中的数据是关联的
        4、销毁父组件时，先将子组件销毁后才会销毁父组件

兄弟组件之间的生命周期
       1、初始化销毁等互相不干扰。
       2、挂载是从上到下依次进行的。


vue指令
        v-model指令： 实现表单输入与应用状态之间的双向绑定
        v-on

自定义指令
        有时候我们需要实现现有指令无法实现的功能，这时我们就可以通过自定义指令来实现功能
        全局注册
                //注册一个全局自定义指令， 'v-focus'
                Vue.directive('focus',{
                //当被绑定的元素插入到DOM 中时
                inserted: function(el){
                //聚焦元素
                    el.focus()
                }
                })
        局部注册
            如果想注册局部指令，组件中也接受一个directives的选项
            directives: {
                focus: {
                    //指令的定义
                    inserted: function(el) {
                        el.focus()
                    }
                }
            }
        之后，就可以在模板的任何元素上使用新的v-focus指令
        <input v-focus />

    指令钩子函数：
        bind
        inserted
        update
        componentUpdated
        unbind
    钩子函数参数
    message: "hello"
        el-----------指令所绑定的元素，可以直接操作DOM
        binding------一个对象，包含下面几个属性
            name---------指令名，不包括"v-"前缀
            value--------指令的绑定值.....hello
            oldValue
            expression------指令的绑定字符串.....message
            arg-------------传给指令的参数
            modifiers-------一个包含修饰符的对象
        vnode--------vue编译生成的虚拟节点
        oldVnode-----上一个虚拟节点，仅在update和componentUpdate钩子中使用

                Vue.directive('color-swatch', function (el, binding) {
                  el.style.backgroundColor = binding.value
                })


组件传值

这里有关网址： https://blog.csdn.net/qq_35430000/article/details/79291287
    父子组件之间的传值主要为prop、event
    组件之间传值的方式有

        1、通过路由待参数进行传值
        2、通过sessionStorage缓存的形式 来进行数据传递
        3、父组件像子组件传值： props
        4、子组件像父组件传值： emit

全局API
	Vue.extend(options)
		----使用构造器创建一个子类，参数是一个包含组件选项的对象。其中不同于组件的是data必须是一个函数


		<div id="rotal">
		    <h1>
		</div>

        //创建构造器
        var rotial = Vue.extend({
            template: "<p>这是:{{firstname}}-{{lastName}}使用vue.extend()定义的一个子组件，看看效果如何..{{alias}}耶</p>",
            data: function(){
                return {
                    firstName: "tan",
                    lastName: "qingqing",
                    alias: "tqq"
                }
            }
        });
        //创建实例，并将内容挂载到元素上
       new rotial().$mount("#rotal")


    Vue.nextTick([callback,context])
        延迟回调函数，在DOM更新后执行该函数，获取更新后的DOM
        参数:
            callback-----function
            context------object

    Vue.set(target,key,value)
        -----向响应式对象中添加一个属性值
    Vue.directive(id,[definition])
        -------获取或者注册一个组件
    Vue.fliter(id,[definition])
        -------注册或者获取一个全局过滤器
    Vue.component(id,[definition])
        -------注册或者获取一个全局组件
        -----Vue.component("my-component",Vue.extend({}));
    Vue.use(pluins)
        -------安装一个vue.js插件
    Vue.mixin(mixin)
        -------全局注册一个混入（全局混入）？？
    Vue.version()
        ---------获取vue的版本。。这样我们就可以根据不同的版本号，采取不同的方式
    Vue.compile(template)
        ------在render函数中编译字符串????


    选项/数据

